# JavaScript函数



### 函数声明

**JavaScript有两种声明函数的办法**

+ 关键字声明：

  使用关键字`function`声明函数：

```javascript
function fn(){
    console.log("我是关键字声明");
}
fn();
```

+ 函数表达式（匿名函数）

```javascript
var fun = function(){
    console.log("我是匿名函数");
}
fun();
```

> 需要注意的是，关键字声明的`fn`是函数名，匿名函数中的`fun`是变量名，与普通的变量类似，不过普通变量保存的是值，而函数变量保存的是一个函数，也可以理解为一个代码块。



### return关键字

​	与其他语言一样，JS也允许函数拥有返回值。在JS的函数中，我们希望函数将值返回给调用它的地方时，可以使用`return`语句，在使用`return`语句时，函数会停止执行，并返回指定的值。

```javascript
function fn(){
	var x=1;
    return x;
}
console.log(fn())
```

> 当程序读到函数中的`return`语句时，只会停止函数的执行而不会停止整个程序。



### arguments对象

​	在JS中，可变参数使用**`arguments`**对象表达。每个函数都内置一个**`arguments`**对象，**`arguments`**对象中存储了所有传递的实参。

```javascript
function fn(){
    console.log(arguments);
}
fn(1,2,3);
```

​	直接打印`arguments`对象的结果为：

```javascript
Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]
// 一个类似于数组的表达式。
```

​	`arguments`对象使用一种类似于数组的数据结构，也叫类数组对象（Array-like Object），拥有数组对象的`length`属性，能够以索引的方式存储数据，因此可以按照处理数组的方式，遍历取值。但是它没有真正的数组的一些类似于`pop()`、`push()`等方法，因此它是一个伪数组。

```javascript
function fn(){
    console.log(arguments.length);  // 输出3
    for (var i = 0; i < arguments.length; i++){
        console.log(arguments[i]);
    }
}
fn(1,2,3);  // 输出1，2，3
```

> 需要注意的是：因为`arguments`是函数内置对象，所以不用在函数参数中定义。function fn(arguments){}这种写法是错误的。

​	`arguments`是类数组对象，可以使用`Array.form()`方法将其转化为真正的数组对象。

```javascript
console.log(Array.form(arguments));
// 输出为[1,2,3]
```



### 作用域

**全局变量：**在函数外声明的变量一般是全局变量，网页上所有的脚本和函数都能访问它。

**局部变量：**在JS函数内部声明的变量一般是局部变量，只能在函数内部访问。

```javascript
var variableOne = "我是全局变量";

function fn(){
    var variableTwo = "我是局部变量";
}
```

**JS变量的生存期：**

+ 全局变量只有在浏览器关闭页面的时候才会被销毁，释放内存。
+ 局部变量会在函数运行完以后被删除销毁。

**向未声明的变量分配值：**

如果把值赋给未声明的变量，该变量会自动作为`window`对象的一个属性。

```javascript
variable = "我是window对象的属性";
// 这句代码将声明window对象的一个属性variable
```



### 预解析（Pre-parsing）

​	预解析是JS解释器再实际执行代码之前执行的一步。在这个阶段，解释器会查看所有的函数和变量声明，并在内存中分配空间。这个过程包括两个关键的动作：

+ **函数声明的预解析：**当解释器遇到关键字（**`function`**）的函数声明时，它会在代码执行之前先读取函数声明，并在内存中为整个函数体分配空间。也就是说，哪怕函数的定义写在调用之后，也不会影响函数的调用。这个过程叫**函数提升**

```javascript
fn();
function fn(){
    console.log(1);
}
// 正常输出，结果为1
```

+ **变量声明的预解析：**对于使用**`var`**关键字的变量声明，解释器会在代码执行前提前识别它们的声明，并在内存中分配空间。但只有声明被提前，赋值则保持在原来的位置。

> **只有声明的过程被提前，赋值的过程不提前！**

```javascript
// 例如：
console.log(variable);
var variable = 123;
// 这样会输出`undefined`
```

​	上述例子之所以会输出`undefined`，是因为变量的声明被提前了，但是赋值并没有被提前，于是代码经过解释器的预解析后变为：

```javascript
var variable;
console.log(variable);
variable = 123;
```

​	因此输出`undefined`。

+ **变量提升（Hoisting）：**

​	变量提升是预解析过程的一个直接结果。在JS中，变量和函数的声明会在代码执行前被“提升”到各自**作用域**的顶部。也就是说，不论声明他们的代码在函数或全局作用域的什么位置，它们都会被视为在作用域的最开始处声明。

+ **一个特殊的例子：匿名函数**

​	先看代码：

```javascript
console.log(fun); // undefined
fun();  // TypeError: fun is not a function
var fun = function(){
    console.log(1);
}
```

​	这个程序会报错：

```javascript
undefined
TypeError: fun is not a function
```

​	这两个报错信息由两句代码引起，第一个报错是因为`fun`变量定义了但未赋值。第二个报错是因为解释器认为`fun`变量不是一个函数。之所以报错信息会这样，是因为前面提到的，函数表达式声明的函数是匿名函数，虽然可以用变量名调用，但它任然只是变量名而不是函数名。因此，上面的代码经过解释器预解析之后变为：

```javascript
var fun;
console.log(fun);
fun();  // fun是变量，不是函数，因此调用会报错。
fun = function(){
    console.log(1);
}
```

​	